" ************************ My own vimrc ******************************

     set t_Co=256
     set t_Sf=[3%dm
     set t_Sb=[4%dm
     set t_mr=[00;33;44m
     set encoding=utf-8

"PATHOGEN/VUNDLE
filetype off
"disble individual pathogen
"let g:pathogen_disabled = ['delimitMate']
" To disable a plugin, add it's bundle name to the following list
let g:pathogen_disabled = []

" for some reason the csscolor plugin is very slow when run on the terminal
" but not in GVim, so disable it if no GUI is running
if !has('gui_running')
        call add(g:pathogen_disabled, 'vim_airline')
endif
call add(g:pathogen_disabled, 'mru')
call add(g:pathogen_disabled, 'multipleHilight')
"we use neocomplete
"call add(g:pathogen_disabled, 'neocomplete')
call add(g:pathogen_disabled, 'checkSyntax')
call add(g:pathogen_disabled, 'savevers')
call add(g:pathogen_disabled, 'neocomplcache')
call add(g:pathogen_disabled, 'neocomplcache-ultisnips')
call add(g:pathogen_disabled, 'ultisnips')
call add(g:pathogen_disabled, 'vimfiler')
"call add(g:pathogen_disabled, 'YouCompleteMe')
call add(g:pathogen_disabled, 'coVim')
call add(g:pathogen_disabled, 'easymotion_2')
call add(g:pathogen_disabled, 'neosnippet')
call add(g:pathogen_disabled, 'YankRing')
call add(g:pathogen_disabled, 'LargeFile')
call add(g:pathogen_disabled, 'cursorcross')
call add(g:pathogen_disabled, 'perforce')
call add(g:pathogen_disabled, 'p4python')
"this is the better plugin: vim_perforce
call add(g:pathogen_disabled, 'vim_perforce')
"call add(g:pathogen_disabled, 'yankstack')
call add(g:pathogen_disabled, 'diffchanges')
call add(g:pathogen_disabled, 'vim-diffchanges')
call add(g:pathogen_disabled, 'diminactive')
call add(g:pathogen_disabled, 'easytags')
call add(g:pathogen_disabled, 'minibufexpl')
call add(g:pathogen_disabled, 'vim-shell')
call add(g:pathogen_disabled, 'Command-T')
call add(g:pathogen_disabled, 'sneak')
call add(g:pathogen_disabled, 'chronos')
call add(g:pathogen_disabled, 'textabyss')
call add(g:pathogen_disabled, 'GoldenView')

"call add(g:pathogen_disabled, 'CSApprox')
"call add(g:pathogen_disabled, 'Command-T')
"call add(g:pathogen_disabled, 'FuzzyFinder')
"call add(g:pathogen_disabled, 'GoldenView')
"call add(g:pathogen_disabled, 'LargeFile')
"call add(g:pathogen_disabled, 'MultipleSearch')
"call add(g:pathogen_disabled, 'NERD_tree')
"call add(g:pathogen_disabled, 'PyScratch')
"call add(g:pathogen_disabled, 'Pydiction')
"call add(g:pathogen_disabled, 'TagmaTasks')
"call add(g:pathogen_disabled, 'TaskList')
"call add(g:pathogen_disabled, 'VisIncr')
"call add(g:pathogen_disabled, 'YankRing')
"call add(g:pathogen_disabled, 'YouCompleteMe')
"call add(g:pathogen_disabled, 'abolish')
"call add(g:pathogen_disabled, 'ack')
"call add(g:pathogen_disabled, 'autocomplete')
"call add(g:pathogen_disabled, 'autohighlight')
"call add(g:pathogen_disabled, 'bluespec')
"call add(g:pathogen_disabled, 'bufexplorer')
"call add(g:pathogen_disabled, 'buffergator')
"call add(g:pathogen_disabled, 'buffergrep')
"call add(g:pathogen_disabled, 'bufkill')
"call add(g:pathogen_disabled, 'calendar')
"call add(g:pathogen_disabled, 'checkSyntax')
"call add(g:pathogen_disabled, 'chronos')
"call add(g:pathogen_disabled, 'coVim')
"call add(g:pathogen_disabled, 'colorSchemeDegrade')
"call add(g:pathogen_disabled, 'colorSchemeEx')
"call add(g:pathogen_disabled, 'color_ChasingLogic')
"call add(g:pathogen_disabled, 'color_FlatColor')
"call add(g:pathogen_disabled, 'color_badwolf')
"call add(g:pathogen_disabled, 'color_base16')
"call add(g:pathogen_disabled, 'color_bubblegum')
"call add(g:pathogen_disabled, 'color_colorschemes')
"call add(g:pathogen_disabled, 'color_distinguished')
"call add(g:pathogen_disabled, 'color_flatui')
"call add(g:pathogen_disabled, 'color_grb256')
"call add(g:pathogen_disabled, 'color_gruvbox')
"call add(g:pathogen_disabled, 'color_harlequin')
"call add(g:pathogen_disabled, 'color_hemisu')
"call add(g:pathogen_disabled, 'color_hybrid')
"call add(g:pathogen_disabled, 'color_laederon')
"call add(g:pathogen_disabled, 'color_lizard')
"call add(g:pathogen_disabled, 'color_luna')
"call add(g:pathogen_disabled, 'color_noctu')
"call add(g:pathogen_disabled, 'color_seoul256')
"call add(g:pathogen_disabled, 'color_sol')
"call add(g:pathogen_disabled, 'color_solarized')
"call add(g:pathogen_disabled, 'color_tomorrow')
"call add(g:pathogen_disabled, 'color_tomorrow_theme')
"call add(g:pathogen_disabled, 'colour_sampler_pack')
"call add(g:pathogen_disabled, 'compview')
"call add(g:pathogen_disabled, 'conque')
"call add(g:pathogen_disabled, 'context_filetype')
"call add(g:pathogen_disabled, 'cscope')
"call add(g:pathogen_disabled, 'csv')
"call add(g:pathogen_disabled, 'ctrlp')
"call add(g:pathogen_disabled, 'ctrlspace')
"call add(g:pathogen_disabled, 'cursorcross')
"call add(g:pathogen_disabled, 'delimitMate')
"call add(g:pathogen_disabled, 'diffchanges')
"call add(g:pathogen_disabled, 'diminactive')
"call add(g:pathogen_disabled, 'dirdiff')
""call add(g:pathogen_disabled, 'dragvisuals')
"call add(g:pathogen_disabled, 'easy_align')
"call add(g:pathogen_disabled, 'easymotion')
"call add(g:pathogen_disabled, 'easymotion_2')
"call add(g:pathogen_disabled, 'easytags')
"call add(g:pathogen_disabled, 'endwise')
"call add(g:pathogen_disabled, 'exchange')
"call add(g:pathogen_disabled, 'fontmanager')
"call add(g:pathogen_disabled, 'fugitive')
"call add(g:pathogen_disabled, 'genutils')
"call add(g:pathogen_disabled, 'gundo')
"call add(g:pathogen_disabled, 'kolor')
"call add(g:pathogen_disabled, 'l9')
"call add(g:pathogen_disabled, 'linediff')
"call add(g:pathogen_disabled, 'lose')
"call add(g:pathogen_disabled, 'matchTagAlways')
"call add(g:pathogen_disabled, 'matchit')
"call add(g:pathogen_disabled, 'minibufexpl')
"call add(g:pathogen_disabled, 'mru')
"call add(g:pathogen_disabled, 'multiple_cursor')
"call add(g:pathogen_disabled, 'mw_utils')
""call add(g:pathogen_disabled, 'my_colors')
"call add(g:pathogen_disabled, 'narrow')
"call add(g:pathogen_disabled, 'neocomplcache')
"call add(g:pathogen_disabled, 'neocomplcache-ultisnips')
"call add(g:pathogen_disabled, 'neocomplete')
"call add(g:pathogen_disabled, 'neosnippet')
"call add(g:pathogen_disabled, 'orgmode')
"call add(g:pathogen_disabled, 'outline')
"call add(g:pathogen_disabled, 'over')
"call add(g:pathogen_disabled, 'p4python')
"call add(g:pathogen_disabled, 'pathogen')
"call add(g:pathogen_disabled, 'perforce')
"call add(g:pathogen_disabled, 'perl-support')
"call add(g:pathogen_disabled, 'perlOmni')
"call add(g:pathogen_disabled, 'perldoc')
"call add(g:pathogen_disabled, 'project')
"call add(g:pathogen_disabled, 'python')
"call add(g:pathogen_disabled, 'quicktask')
""call add(g:pathogen_disabled, 'rainbow_parentheses')
"call add(g:pathogen_disabled, 'repeat')
"call add(g:pathogen_disabled, 'savevers')
"call add(g:pathogen_disabled, 'scratch')
"call add(g:pathogen_disabled, 'shell-executor')
"call add(g:pathogen_disabled, 'sleuth')
"call add(g:pathogen_disabled, 'sneak')
"call add(g:pathogen_disabled, 'snippets')
"call add(g:pathogen_disabled, 'solarized')
"call add(g:pathogen_disabled, 'startify')
"call add(g:pathogen_disabled, 'striptease')
"call add(g:pathogen_disabled, 'surround')
"call add(g:pathogen_disabled, 'table')
"call add(g:pathogen_disabled, 'tabpagecolorscheme')
"call add(g:pathogen_disabled, 'tabular')
"call add(g:pathogen_disabled, 'tagbar')
"call add(g:pathogen_disabled, 'taglist')
"call add(g:pathogen_disabled, 'textabyss')
"call add(g:pathogen_disabled, 'tlib')
"call add(g:pathogen_disabled, 'tmux-navigator')
"call add(g:pathogen_disabled, 'tmux_complete')
"call add(g:pathogen_disabled, 'undoTree')
"call add(g:pathogen_disabled, 'unite')
"call add(g:pathogen_disabled, 'unite_qfix')
"call add(g:pathogen_disabled, 'utl')
"call add(g:pathogen_disabled, 'verilog')
"call add(g:pathogen_disabled, 'verilog_systemverilog')
"call add(g:pathogen_disabled, 'vim-diffchanges')
"call add(g:pathogen_disabled, 'vim-dispatch')
"call add(g:pathogen_disabled, 'vim-expand-region')
"call add(g:pathogen_disabled, 'vim-misc')
"call add(g:pathogen_disabled, 'vim-shell')
"call add(g:pathogen_disabled, 'vim-support')
""call add(g:pathogen_disabled, 'vim_airline')
"call add(g:pathogen_disabled, 'vim_colors_babymate256')
"call add(g:pathogen_disabled, 'vim_indent_guides')
"call add(g:pathogen_disabled, 'vim_monokai')
"call add(g:pathogen_disabled, 'vim_nocturne')
"call add(g:pathogen_disabled, 'vim_perforce')
"call add(g:pathogen_disabled, 'vim_session')
"call add(g:pathogen_disabled, 'vimfiler')
"call add(g:pathogen_disabled, 'vimproc')
"call add(g:pathogen_disabled, 'vimux')
"call add(g:pathogen_disabled, 'vinegar')
"call add(g:pathogen_disabled, 'visualGuide')
"call add(g:pathogen_disabled, 'vmath')
"call add(g:pathogen_disabled, 'vundle')
"call add(g:pathogen_disabled, 'xml')
"call add(g:pathogen_disabled, 'yankstack')
"call add(g:pathogen_disabled, 'zoomwin')

call pathogen#infect()
call pathogen#helptags()
"VUNDLE
"set rtp+=~/.vim/bundle/vundle/
"call vundle#rc()
" let Vundle manage Vundle
" required!
"Bundle 'gmarik/vundle'
" Brief help
" :BundleList          - list configured bundles
" :BundleInstall(!)    - install(update) bundles
" :BundleSearch(!) foo - search(or refresh cache first) for foo
" :BundleClean(!)      - confirm(or auto-approve) removal of unused bundles
" :BundleUpdate
"
" see :h vundle for more details or wiki for FAQ
" NOTE: comments after Bundle command are not allowed..
"
"do yankstack mapping before everything
call yankstack#setup()

"syntax highlighting..
"syntax on
"filetype plugin indent on
" source neocomplete
" neocomplcache is older one
source $HOME/.vim/neo_complete
" youcompleteme disable on certain filetypes
let g:ycm_filetype_specific_completion_to_disable = {}
" Solid line for vsplit separator
set fcs=vert:'|'
"
" Always splits to the right and below
"set splitright
"set splitbelow
"
" Set to auto read when a file is changed from the outside
"set autoread
"
" Set to auto write file
"set autowriteall
"
" Give one virtual space at end of line
"set virtualedit=onemore
"Square up visual selections...
set virtualedit=block
" when switching buffer go to the open one"
set switchbuf=useopen,usetab

"settings handy ..
" Display an incomplete command in the lower right corner of the Vim window
set showcmd
set cpoptions=Aq
" no long listing"
set nomore          "Don't page long listings
"
"allow to delete using backspace
"set backspace=2
set backspace=indent,eol,start
" Set xterm2 mouse mode to allow resizing of splits with mouse inside Tmux.
"no color sleep through in tmux"
if &term =~ '256color'
  " Disable Background Color Erase (BCE) so that color schemes
  " work properly when Vim is used inside tmux and GNU screen.
  " See also http://snk.tuxfamily.org/log/vim-256color-bce.html
  set t_ut=
endif
set ttymouse=xterm2
" other whitespace and indenting related settings
" auto-indent amount when using cindent, >>, << and stuff like that
set shiftwidth=2
set softtabstop=2
" multiples of shiftwidth when using >
set shiftround
set grepprg=grep\ -rnH\ --exclude='.*.swp'\ --exclude='*~'\ --exclude=tags
set sw=2
" real tabs should be 8, and they will show with set list on
set tabstop=8
"dont show statusline messages
"hide the insert mode displays
set noshowmode
"set modeline parsing
set modeline
" rt clk pops up a menu"
" set mousemodel=popup
set laststatus=2 ruler 
"dont refresh screen when executing macros
set lazyredraw
set expandtab
"set shiftwidth=8 tabstop=8 nowrap joinspaces magic report=0 dict=/usr/dict/words
set shell=csh
set wildchar=<TAB>
set incsearch
"set guifont=-b&h-lucidatypewriter-medium-r-normal-*-*-140-*-*-m-*-iso8859-15

" Make regex a little easier to type
set magic

" Column width indicator only for lines exceeding
highlight ColorColumn ctermbg=magenta
" FIXME this is slowing vim down
" call matchadd('ColorColumn', '\%81v', 100)
"set colorcolumn=+1

"set rel num and current line number"
set relativenumber
set number
set nowrapscan
set nowrap
" now i am trying to have backup files
set nobackup
set nowritebackup
"set patchmode=.clean
"set backupskip+=*
set backupdir=./backup,~/backup,~/.vim/backup,.
" save backups in some dir
let savevers_max = 99
let savevers_dirs = &backupdir
"making backup
let savevers_types = "*,.vimrc,.tmux.conf,.my_cshrc_custom,.my_custom_aliases,tmp_*,cmd_line,neo_complcache,neo_complete,*.txt,*.c,*.cpp,*.h,.vimrc,*.vim,vimrcNV,*.sv,*.svx,*.svh,*.svhx,*.svi,*.svix,README,readme,Readme,*.vxh,*.vh,*.vhx,*.svi,*.svix,*.v,*.vx,*.vt,*.vtx,*.vxt,*.snippets,*.config,cmd_line.*.mk,*.nvmk,*.make,Make*,*.inc,*.weld,*.testlist,*.xml,*.tcl,*.pl,*.pm,*.yaml,*.py,*.sh,*.csh.*.spec,*.def,*.csv"
set noswapfile
set undolevels=1000
" viminfo stores the the state of your previous editing session
set ssop-=options    " do not store global and local values in a session
set ssop-=folds      " do not store folds
"Session options"
let g:session_directory='~/vim_session/'
let g:session_extension='.ses'
let g:session_autosave_periodic=15
let g:session_autosave='no'
set viminfo+=n~/.vim/viminfo
if exists("+undofile")
  " undofile - This allows you to use undos after exiting and restarting
  " This, like swap and backups, uses .vim-undo first, then ~/.vim/undo
  " :help undo-persistence
  " This is only present in 7.3+
  "if isdirectory($HOME . '/.vim/undo') == 0
  "  :silent !mkdir -p ~/.vim/undo >& /dev/null
  "endif
  set undodir=./.vim-undo//
  set undodir+=~/.vim/undo//
endif
if has("persistent_undo")
  set undodir+=~/.vim/undo/
endif
set undofile
"Show matching bracets when text indicator is over them
set showmatch
set hlsearch
set diffopt+=iwhite
set diffopt+=context:3
set linebreak
set autoindent
set smartindent
" This is a personal preference, I copy with 'as is' indent, the use '<' or '>' on visual to change it
set copyindent
" For smartindent, don't handle # specially
" don't force preprocessor lines at column 1
set cinkeys-=0#
"inoremap # X#
set smarttab
set cindent
set cinoptions=:s,ps,ts,cs
set cinwords=if,else,while,do,for,switch,case
if  has("gui_running")
  let indent_guides_enable_on_vim_startup = 1
endif
set ignorecase
set infercase " case inferred by default
set smartcase
"scroll offset"
set scrolloff=2 "skip 2 lines when scrolling
""confirm action using a dialog box
set confirm
set nostartofline
" always show something in statusline
set report=0 " tell us when anything is changed via :...
"leave my cursor where it was"
"change to the current dir automatically
set autochdir
"open file in the current buffer dir
set browsedir=buffer
"change the cmd window
"set cmdheight=2
"small status msg for vim
set shortmess=atToOI
"set shortmess=aOstT " shortens messages to avoid 'press a key' prompt
set wildignore+=*\\tmp\\*,*.swp,*.zip,*.exe,*.o,*.obj,*.a,*.lib,*.elf,*.dll
set wildignore+=*.a,*.o
set wildignore+=*.bmp,*.gif,*.ico,*.jpg,*.png
set wildignore+=.DS_Store,.git,.hg,.svn
set wildignore+=*~,*.swp,*.tmp
" Make shift-insert work like in Xterm
map <S-Insert> <MiddleMouse>
map! <S-Insert> <MiddleMouse>
map <C-S-Insert> <MiddleMouse>
map! <C-S-Insert> <MiddleMouse>
" Writes to the unnamed register also writes to the * and + registers. This
" makes it easy to interact with the system clipboard
"if has ('unnamedplus')
"  set clipboard=unnamedplus
"else
"  set clipboard=unnamed
"endif
"set clipboard+=unnamed " share windows clipboard
"set clipboard^=unnamed " share windows clipboard
set clipboard=autoselect
vnoremap p "_dP
"automatically go to the last of the paste
"nnoremap p p`]
"quickly select text u pasted
noremap gV `[v`]
"for replacing a visual
" vmap <C-r> "_dP
" vnoremap p "0P
" vnoremap P "0P
" xnoremap p "_dP
" xnoremap P "_dP

"home moves cursor to the first non-blank char
noremap <expr> <silent> <Home> col('.') == match(getline('.'),'\S')+1 ? '0' : '^'
imap <silent> <Home> <C-O><Home>
nnoremap 0 ^

"perforce settings
let g:p4EnableRuler=0
let g:p4EnableActiveStatus=0
let g:p4OptimizeActiveStatus = 1

"I want mouse settings also ..
set mouse=a
"           +--Disable hlsearch while loading viminfo
"           | +--Remember marks for last 50 files
"           | |   +--Remember up to 10000 lines in each register
"           | |   |      +--Remember up to 1MB in each register
"           | |   |      |     +--Remember last 1000 search patterns
"           | |   |      |     |     +---Remember last 1000 commands
"           | |   |      |     |     |
"           v v   v      v     v     v
set viminfo=h,'50,<10000,s1000,/1000,:1000

"set viminfo='20,\"50	" read/write a .viminfo file, don't store more
				" than 50 lines of registers
set history=500000         " keep 50 lines of command line history

"sets color of cursor according to the color of its text ..... looks fundu
set t_vs=[5%dm

"disable all folding
"set nofoldenable
function! NeatFoldText() "{{{2
  let line = ' ' . substitute(getline(v:foldstart), '^\s*"\?\s*\|\s*"\?\s*{{' . '{\d*\s*', '', 'g') . ' '
  let lines_count = v:foldend - v:foldstart + 1
  let lines_count_text = '| ' . printf("%10s", lines_count . ' lines') . ' |'
  let foldchar = matchstr(&fillchars, 'fold:\zs.')
  let foldtextstart = strpart('+' . repeat(foldchar, v:foldlevel*2) . line, 0, (winwidth(0)*2)/3)
  let foldtextend = lines_count_text . repeat(foldchar, 8)
  let foldtextlength = strlen(substitute(foldtextstart . foldtextend, '.', 'x', 'g')) + &foldcolumn
  return foldtextstart . repeat(foldchar, winwidth(0)-foldtextlength) . foldtextend
endfunction
set foldtext=NeatFoldText()
" }}}2

" I work  in javascript also ...
"set formatoptions-=tc
set wrapmargin=0
set textwidth=0
set formatoptions=crqwnl1
set formatoptions-=t

"Change buffer - without saving
"buffer to background without saving
set hidden

" I don't like bells .
set noerrorbells
set visualbell
" disable any beeps or flashes on error
set vb t_vb=
""
" echo something on leaving .......
"au VimLeave * echo "Another file ..... gosh I am tired !!"

 " correct these frequent typographical errors
source $HOME/.vim/spell_correct

"source $VIM/macros/file_select.vim
"map - :set wrapmargin=0<CR>
"map + :set wrapmargin=8<CR>
""map K j.
map <C-^> <C-]>

"menu
:source $VIMRUNTIME/menu.vim

"filelist Completion options
set completeopt=longest,menuone
set wildmode=longest,list,full
set wildignorecase
" tmux complete
let g:tmux_complete_location = "~/.vim/bundle/tmux_complete"

"command line suggestion
set wildmenu
:set cpo-=<
:set wcm=<C-Z>
"":map <F4> :emenu <C-Z>
"visual special charaters
"" Highlight problematic whitespace
if  has("gui_running")
  "set list
  "highlight NonText ctermfg=8 guifg=gray
  "set listchars=tab:§»,extends:¶,eol:¬
  "if &encoding == "utf-8"
  "   set listchars=nbsp:\u2422,conceal:\u22ef,tab:\u2595\u2014,trail:\u02d1,precedes:\u2026,extends:\u2026"
  "else
  "   set listchars=eol:$,trail:-,tab:>-,extends:>,precedes:<,conceal:+
  "endif
endif
"get new chanracters from dig
" use C-k to insert
"set showbreak=§
" Make trailing whitespace annoyingly highlighted.
highlight ExtraWhitespace ctermbg=red guibg=red
match ExtraWhitespace /\s\+$/
augroup MyAutoCmd
  autocmd BufEnter * match ExtraWhitespace /\s\+$/
  "autocmd VimLeavePre * bufdo Purge
  autocmd InsertEnter * match ExtraWhitespace /\s\+\%#\@<!$/
  autocmd InsertLeave * match ExtraWhitespace /\s\+$/
  autocmd BufUnload * call clearmatches()
  " add this so that future colorscheme changes dont overwrite it"
  autocmd ColorScheme * highlight ExtraWhitespace ctermbg=red guibg=red
  " remove trailing spaces"
  "autocmd FileType c,cpp,java,php,perl,yaml,vim autocmd BufWritePre <buffer> :%s/\s\+$\|^\s\+$//e
" Turn on cursorline only on active window
  autocmd WinLeave * setlocal nocursorline
  autocmd WinEnter,BufRead * setlocal cursorline
  " rainbow parenthesis
  autocmd VimEnter * RainbowParenthesesToggle
  autocmd Syntax * RainbowParenthesesLoadRound
  autocmd Syntax * RainbowParenthesesLoadSquare
  autocmd Syntax * RainbowParenthesesLoadBraces
  autocmd BufNewFile,BufRead,BufWritePre *.log setf log|setlocal wrap|setlocal nobackup|setlocal noundofile
  autocmd BufNewFile,BufRead,BufWritePre *.log.retry setf log|setlocal nobackup|setlocal noundofile
  autocmd BufNewFile,BufRead,BufWritePre *testout* setf log|setlocal nobackup|setlocal noundofile
  autocmd BufNewFile,BufRead,BufWritePre /tmp/* setf log|setlocal nobackup|setlocal noundofile
  autocmd BufNewFile,BufRead,BufEnter */t186/* setlocal nomodifiable
  autocmd BufNewFile,BufRead,BufEnter */tlit4/* setlocal nomodifiable
  autocmd BufNewFile,BufRead,BufEnter */t210/* setlocal nomodifiable
  autocmd BufNewFile,BufRead,BufEnter */tlit2/* setlocal nomodifiable
augroup END
"Rainbow paren
let g:rbpt_colorpairs = [
    \ ['brown',       'RoyalBlue3'],
    \ ['Darkblue',    'SeaGreen3'],
    \ ['darkgray',    'DarkOrchid3'],
    \ ['darkgreen',   'firebrick3'],
    \ ['darkcyan',    'RoyalBlue3'],
    \ ['darkred',     'SeaGreen3'],
    \ ['darkmagenta', 'DarkOrchid3'],
    \ ['brown',       'firebrick3'],
    \ ['gray',        'RoyalBlue3'],
    \ ['black',       'SeaGreen3'],
    \ ['darkmagenta', 'DarkOrchid3'],
    \ ['Darkblue',    'firebrick3'],
    \ ['darkgreen',   'RoyalBlue3'],
    \ ['darkcyan',    'SeaGreen3'],
    \ ['darkred',     'DarkOrchid3'],
    \ ['red',         'firebrick3'],
    \ ]
let g:rbpt_max = 16
let g:rbpt_loadcmd_toggle = 0

"remove the trailing white spaces
"set listchars=tab:>.,trail:.,extends:\#,nbsp:.

" kick off emax
"map <F10> :!emacs -nw %<CR>:e!<CR><CR>

" exeute current line
" map <F10> "hyy@h
map <F10> :echo "hi<" . synIDattr(synID(line("."),col("."),1),"name") . '> trans<'
\ . synIDattr(synID(line("."),col("."),0),"name") . "> lo<"
\ . synIDattr(synIDtrans(synID(line("."),col("."),1)),"name") . ">"<CR>

cnoremap <C-A> <Home>
cnoremap <C-F> <Right>
cnoremap <C-B> <Left>
cnoremap <M-b>  <S-Left>
cnoremap <M-f>  <S-Right>
cnoremap <M-d>  <S-right><Delete>
"make alt arrows to behave like browser"
nnoremap <M-Left> <C-o>
nnoremap <M-Right> <C-i>
cnoremap <ESC>b <S-Left>
cnoremap <Esc>d <S-right><Delete>
cnoremap <ESC>f <S-Right>
cnoremap <ESC><C-H> <C-W>
"buffer navigation
nmap <C-q> :e!<CR>
nnoremap gb :ls<CR>:sb
"ctrlp options
let g:ctrlp_root_markers = ['TOT']
let g:ctrlp_map = '<c-p>'
"let g:ctrlp_cmd = 'CtrlPMixed'
let g:ctrlp_cmd = 'CtrlP'
let g:ctrlp_working_path_mode = 'carw'
let g:ctrlp_clear_cache_on_exit = 0
let g:ctrlp_follow_symlinks = 1
let g:ctrlp_max_files = 0
let g:ctrlp_user_command = ['TOT', 'cd %s && cat files | grep -v -e "/\." ', 'find %s -type f']
"sneak
"let g:sneak#streak = 1
"let g:sneak#s_next = 0
"nmap f <Plug>Sneak_f
"nmap F <Plug>Sneak_F
"xmap f <Plug>Sneak_f
"xmap F <Plug>Sneak_F
"omap f <Plug>Sneak_f
"omap F <Plug>Sneak_F
"nmap t <Plug>Sneak_t
"nmap T <Plug>Sneak_T
"xmap t <Plug>Sneak_t
"xmap T <Plug>Sneak_T
"omap t <Plug>Sneak_t
"omap T <Plug>Sneak_T

"cursor movement
"j and k should follow the screen
nnoremap j gj
nnoremap k gk
vnoremap j gj
vnoremap k gk
nnoremap <Down> gj
nnoremap <Up> gk
vnoremap <Down> gj
vnoremap <Up> gk
"inoremap <Down> <C-o>gj
"inoremap <Up> <C-o>gk
nnoremap gf gF
nnoremap <C-w><C-f> <C-w><S-f>
nnoremap <C-w>gf <C-w>gF
:command Qa qa
:command QA qa
:command WQ wq
:command Wq wq
:command W w
:command Q q
:command Sp sp
:command Vs vs
"follow symlinks"
"command! -nargs=1 -complete=file EF call EditFile(<f-args>)
"nnoremap EF :execute "edit " . resolve(expand(<f-args>))
"":cabbrev e <c-r>=(getcmdtype()==':' && getcmdpos()==1 ? 'EF' : 'e')<CR>
function! EditFile(filename)
  if getftype(a:filename) == "link"
    edit resolve(expand(a:filename))
  else
    edit a:filename
  endif
endfunction
" Take off and nuke the entire buffer contents from space
" (It's the only way to be sure)...
nmap XX 1GdG
":cabbrev w <c-r>=(getcmdtype()==':' && getcmdpos()==1 ? 'W' : 'w')<CR>

"-------------> Edit compressed files <-------------
":autocmd! BufReadPre,FileReadPre  	*.gz set bin
":autocmd  BufReadPost,FileReadPost	*.gz '[,']!gunzip
":autocmd  BufReadPost,FileReadPost	*.gz set nobin
":autocmd! BufWritePost,FileWritePost	*.gz !mv <afile> <afile>:r
":autocmd  BufWritePost,FileWritePost	*.gz !gzip <afile>:r
":autocmd! FileAppendPre			*.gz !gunzip <afile>
":autocmd  FileAppendPre			*.gz !mv <afile>:r <afile>
":autocmd! FileAppendPost		*.gz !mv <afile> <afile>:r
":autocmd  FileAppendPost		*.gz !gzip <afile>:r
"autoload vimrc
"autoload VIMRC
"augroup myvimrc
"    au!
"    au BufWritePost .vimrc,_vimrc,vimrc,.gvimrc,_gvimrc,gvimrc so $MYVIMRC | if has('gui_running') | so $MYVIMRC | endif
"augroup END
augroup filetype_vim
:autocmd!
:autocmd FileType vim setlocal textwidth=0
augroup END

augroup filetype_cfg
:autocmd!
:autocmd BufNewFile,BufRead,BufEnter *.cfg setf yaml|set syntax=yaml
augroup END

"-------------> Perl programs <-------------
augroup filetype_perl
:autocmd!
:autocmd BufEnter  *.pl		set ai si cin formatoptions=croql|set iskeyword+=_ |set filetype=perl |setlocal comments=b:# |set iskeyword-=:
:autocmd BufEnter  *.pm		set ai si cin formatoptions=croql|set iskeyword+=_ |set filetype=perl |setlocal comments=b:# |set iskeyword-=:
:autocmd BufLeave  *.pl		set nosi nocin formatoptions=tcq |set comments=sr:/*,mb:*,el:*/,://,b:#,:%,:XCOMM,n:>,fb:-
":au BufNewFile,BufRead *.pl setf perl
":au BufNewFile,BufRead *.pm setf pod|setlocal syntax=perl
augroup END

"without this crontab does not work
augroup filetype_crontab
:autocmd!
:autocmd FileType crontab set backupcopy=yes
augroup END

augroup filetype_snippets
:autocmd!
:autocmd FileType snippets setlocal modeline
augroup END

"-------------> Create tags   <-------------
" cscope
set tags+=$HOME/ctags/vrtl/tags,tags;`depth`
let g:easytags_dynamic_files = 1
:set cscopequickfix=s-,c-,d-,i-,t-,e-,g-

"-------------> C programs and header files <-------------
augroup filetype_java
:autocmd!
:autocmd BufEnter *.java,*.l,*.y,*.c,*.cc,*.h,*.r set ai si cin formatoptions=crql
:autocmd BufLeave *.java,*.l,*.y,*.c,*.cc,*.h,*.r set nosi nocin formatoptions=tcq
":autocmd BufEnter *.java,*.l,*.y,*.c,*.cc,*.h,*.r set comments=sr:/*,mb:*,el:*/,://
":autocmd BufLeave *.java,*.l,*.y,*.c,*.cc,*.h,*.r set comments=sr:/*,mb:*,el:*/,://,b:#,:%,:XCOMM,n:>,fb:-
":autocmd BufEnter *.java,*.l,*.y,*.c,*.cc,*.h,*.r map <F1> :!man -a <cword><CR><CR>
":autocmd BufEnter *.l,*.y,*.c,*.cc,*.h,*.r map <F2> mpI/* <ESC>A */<ESC>`pj
":autocmd BufEnter *.l,*.y,*.c,*.cc,*.h,*.r map <F3> mp^3x$xxx`pj
":autocmd BufEnter *.java                   map <F2> mpI//<ESC>`pj
":autocmd BufEnter *.java                   map <F3> mp^2x`pj
":autocmd BufEnter *.java,*.l,*.y,?akefile*,*.c,*.cc,*.h,*.r map <F4> :!ctags -t *.{c,cc,h}<CR>
":autocmd BufLeave *.java,*.l,*.y,*.c,*.cc,*.h,*.r unmap <F1>
":autocmd BufLeave *.java,*.l,*.y,*.c,*.cc,*.h,*.r unmap <F2>
":autocmd BufLeave *.java,*.l,*.y,*.c,*.cc,*.h,*.r unmap <F3>
":autocmd BufLeave *.java,*.l,*.y,?akefile*,*.c,*.cc,*.h,*.r unmap <F4>
augroup END

augroup filetype_xml
:autocmd!
:autocmd BufEnter *.xml set filetype=xml
:autocmd BufEnter *.xml set foldcolumn=4
let g:xml_syntax_folding=1
:autocmd FileType xml setlocal foldmethod=syntax
:autocmd BufUnload *.xml syntax clear
augroup END

"-------------> Lisp source files <-------------
augroup filetype_lisp
:autocmd!
:autocmd BufEnter  *.l		set lisp sm
:autocmd BufEnter  *.l		source $VIM/syntax/lisp.vim
:autocmd BufEnter  *.l		map <F5> :w<CR>:!akcl < %<CR>
:autocmd BufEnter  *.l		map! <F5> <ESC>:w<CR>:!akcl < %<CR>
:autocmd BufLeave  *.l		set nolisp nosm
:autocmd BufLeave  *.l		unmap <F5>
:autocmd BufLeave  *.l		unmap! <F5>
:autocmd BufLeave  *.l		syntax clear
augroup END

"-------------> TeX & LaTeX source files <-------------
augroup filetype_tex
:autocmd!
:autocmd BufEnter *.tex		map! <F1> }
:autocmd BufEnter *.tex		map! <F2> {\bf
:autocmd BufEnter *.tex		map! <F3> {\em
:autocmd BufEnter *.tex		map! <F4> {\

:autocmd BufEnter *.tex		ab hp hyperplane
:autocmd BufEnter *.tex		ab hps hyperplanes
:autocmd BufEnter *.tex		ab hc hypercube
:autocmd BufEnter *.tex		ab hcs hypercubes
:autocmd BufEnter *.tex		ab nd n-dimensional
:autocmd BufEnter *.tex		ab kd k-dimensional
:autocmd BufEnter *.tex		ab gc graycode
augroup END

"-------------> Haskell source files <-------------
augroup filetype_haskell
:autocmd!
:autocmd BufEnter *.gs		map <F1> :w<CR>:!gofer %<CR>
:autocmd BufLeave *.gs		unmap <F1>
augroup END

augroup filetype_patch
:autocmd!
:autocmd BufEnter *patch* setlocal filetype=patch |setlocal syntax=diff
:autocmd Bufunload *patch* syntax clear
augroup END

augroup PatchDiffHighlight
  autocmd!
  autocmd FileType  diff   syntax enable
augroup END

augroup filetype_make
:autocmd!
:au BufNewFile,BufRead Makeppfile setf make |setlocal ts=4 sts=4 sw=4 noexpandtab
:au BufNewFile,BufRead Makeppfile.* setf make |setlocal ts=4 sts=4 sw=4 noexpandtab
:au BufNewFile,BufRead *.make setf make |setlocal ts=4 sts=4 sw=4 noexpandtab
:au BufNewFile,BufRead rtlmakefile.inc setf make |setlocal ts=4 sts=4 sw=4 noexpandtab
:au BufNewFile,BufRead vplmakefile.inc setf make |setlocal ts=4 sts=4 sw=4 noexpandtab
:au BufNewFile,BufRead vcsmakefile.inc setf make |setlocal ts=4 sts=4 sw=4 noexpandtab
:au BufNewFile,BufRead *.config setf make |setlocal ts=4 sts=4 sw=4 expandtab
":autocmd BufLeave,FocusLost  Makefile* silent! wall
augroup END
"local make
set makeprg=mk64\ $*

augroup filetype_verilog
:autocmd!
":au BufNewFile,BufRead *.sv setf verilog |set foldmethod=indent/syntax|set foldnestmax=12|set shiftwidth=4|set softtabstop=4|set tabstop=4
":au BufNewFile,BufRead *.sv setf verilog |setlocal foldnestmax=12|setlocal shiftwidth=4|setlocal softtabstop=4|setlocal tabstop=4|setlocal fdc=4|setlocal foldopen+=search|source \~/.vim/cus_fold/folding.vim|call MarkdownSVFolds()
:au BufNewFile,BufRead *.sv setf verilog_systemverilog |setlocal foldnestmax=12|setlocal shiftwidth=4|setlocal softtabstop=4
:au BufNewFile,BufRead *.ness setf verilog_systemverilog |setlocal foldnestmax=12|setlocal shiftwidth=4|setlocal softtabstop=4
:au BufNewFile,BufRead *.spp setf verilog
:au BufNewFile,BufRead *.vx setf viva
:au BufNewFile,BufRead *.v setf viva
:au BufNewFile,BufRead *.vcp setf viva
:au BufNewFile,BufRead *.vcp.err setf viva
:au BufNewFile,BufRead *.vhx setf viva
:au BufNewFile,BufRead *.vxh setf viva
:au BufNewFile,BufRead *.vhxcp.err setf viva
:au BufNewFile,BufRead *.vtx setf verilog
:au BufNewFile,BufRead *.svx setf verilog_systemverilog
:au BufNewFile,BufRead *.svix setf verilog_systemverilog
:au BufNewFile,BufRead *.svcp setf verilog_systemverilog
:au BufNewFile,BufRead *.svi setf verilog_systemverilog
:au BufNewFile,BufRead *.svixcp setf verilog_systemverilog
:au BufNewFile,BufRead *.gv setf verilog
:au BufNewFile,BufRead *.spec setf verilog
:au BufNewFile,BufRead *.vhxcp setf verilog
:au BufNewFile,BufRead *.svh setf verilog_systemverilog|setlocal foldnestmax=12|setlocal shiftwidth=4|setlocal softtabstop=4
:au BufNewFile,BufRead *.svhx setf verilog_systemverilog

:au Filetype *verilog* set softtabstop=2
:au BufReadPost * if exists("b:current_syntax")
:au BufReadPost *   if b:current_syntax == "verilog"
:au BufReadPost *     let b:verilog_indent_modules = 1
:au BufReadPost *   endif
:au BufReadPost * endif
  " When editing a file, always jump to the last cursor position
:autocmd BufReadPost *
  \ if line("'\"") > 0 && line ("'\"") <= line("$") |
  \   exe "normal g'\"" |
  \ endif
:au BufReadPost,BufNewFile *
  \ runtime macros/matchit.vim |
  \ let b:match_words = '\<begin\>:\<end\>,\<fork\>:\<join\>,\<module\>:\<endmodule\>,\<task\>:\<endtask\>,\<function\>:\<endfunction\>,\<class\>:\<endclass\>,\<program\>:\<endprogram\>,\<case\>:^[ |<C-I>]*[^"]\+ *\::\<endcase\>,`ifdef:`else:`elsif:`endif,'
augroup END

"-------------> VIVA Files <-------------------------
":source ~/.vim/syntax/viva.vim
":au BufNewFile,BufRead *.vx,*.v set ft=bsv
":au BufNewFile,BufRead *.vhx,*.v set ft=bsv
":au BufNewFile,BufRead *.vtx,*.v set ft=bsv
":au BufNewFile,BufRead *.svx,*.svix set ft=bsv
":au BufNewFile,BufRead *.svcp,*.svi set ft=bsv
"-------------> Html Files <-------------------------
augroup filetype_html
  :autocmd!
  nmap  ,e :e ~/.P/
  map   ,rn :0r ~/.P/txt/New.page.form.html
  nmap  ,p :!chmod 644 %<CR>
  ab Ybr <br>
  ab Yhr <hr>
  ab Yp  <p>
  map ,me yiwi<<ESC>ea></<C-R>"><ESC>
  ab  Ycom  <!--X--><ESC>FXs
  vmap ,com v`<i<!--<ESC>`>i--><ESC>
  ab  Ybl  <blockquote></blockquote><ESC>T>i
  ab  Yb   <b>i</b><ESC>T>
  vmap ,b   "zdi<b><C-R>z</b><ESC>2F>
  ab  Ycen <center></center><ESC>T>i
  vmap ,cen "zdi<center><C-M><C-R>z<C-M></center><ESC>T>i
  ab  Ycod <code></code><ESC>T>i
  vmap ,cod "zdi<code><C-M><C-R>z<C-M></code><C-M><ESC>T>i
  ab  Yi   <i></i><ESC>T>i
  vmap ,i   "zdi<i><C-R>z</i><ESC>T>
  ab  Ytt   <tt></tt><ESC>T>i
  vmap ,tt   "zdi<tt><C-R>z</tt><ESC>T>
  ab  Ypre <pre></pre><ESC>T>i
  vmap ,pre mz:<ESC>'<O<pre><ESC>'>o</pre><ESC>`z
  ab  Yxmp <xmp></xmp><ESC>T>i
  vmap ,xmp mz:<ESC>'<O<xmp><ESC>'>o</xmp><ESC>`z
  ab  Ytd  <td></td><ESC>T>i
  vmap ,td  "zdi<td><C-R>z</td><ESC>T>i
  ab  Ytr  <tr></tr><ESC>T>i
  vmap ,tr  "zdi<tr><C-R>z</tr><ESC>T>i
  ab  Yh1 <h1></h1><ESC>T>i
  vmap ,h1 "zdi<h1><C-R>z</h1><ESC>2F>
  ab  Yh2 <h2></h2><ESC>T>i
  vmap ,h2 "zdi<h2><C-R>z</h2><ESC>2F>
  ab  Yh3 <h3></h3><ESC>T>i
  vmap ,h3 "zdi<h3><C-R>z</h3><ESC>2F>
  ab  Yh4 <h4></h4><ESC>T>i
  vmap ,h4 "zdi<h4><C-R>z</h4><ESC>2F>
  ab  Yh5 <h5></h5><ESC>T>i
  vmap ,h5 "zdi<h5><C-R>z</h5><ESC>2F>
  ab  Yh6 <h6></h6><ESC>T>i
  vmap ,h6 "zdi<h6><C-R>z</h6><ESC>2F>
  ab Yol <ol><CR><li><CR></ol><ESC>k
  ab Yul <ul><CR><li><CR></ul><ESC>k
  ab Ydl <dl><CR><CR><dt><CR><dd><CR><p><CR><CR></dl><CR><ESC>5kA
  ab Yli <li>
  ab Ydt <dt><CR><dd><CR><p><CR><ESC>kA
  ab Ydp <dt><CR><dd><C-M><p><C-M><ESC>kkkA
  ab  Yhref <a href=""></a><ESC>?""<CR>a
  vmap ,href "zdi<a href=""><C-R>z</a><ESC>F"i
  ab  Ylink <a href=""></a><ESC>?""<CR>a
  vmap ,link "zdi<a href="<C-R>z"<C-M><C-I>><C-R>z</a><ESC>F"i
  ab  Yname <a name=""></a><ESC>?""<CR>a
  vmap ,name "zdi<a name="<C-R>z"<C-M><C-I>><C-R>z</a><ESC>2F>
  ab  Yimg  <img alt="[]"<C-M>   align=<C-M>     src=""></a><ESC>?""<CR>a
  ab  Ymail <a href="mailto:"></a><ESC>?:<CR>a
  vmap ,mail "zdi<a href="mailto:<C-R>z"<C-M><C-I><C-I>><C-R>z</a><ESC>2F>
  vmap ,Mail "zdi<a href="mailto:<C-R>z"><C-R>z</a><ESC>2F>
  ab  Ynews <a href="news:"></a><ESC>?:<CR>a
  vmap ,news "zdi<a href="news:<C-R>z"><C-R>z</a><ESC>2F>
  ab  Ypage   <C-M>page:<C-I><C-M>link:<C-I><C-M>text:<C-I><ESC>kkA
  vmap ,Cblu "zdi<FONT COLOR="#0000FF"><C-R>z</FONT>
  vmap ,Cgre "zdi<FONT COLOR="#00FF00"><C-R>z</FONT>
  vmap ,Cred "zdi<FONT COLOR="#FF0000"><C-R>z</FONT>
  imap ;& &amp;
  imap ;" &quot;
  imap ;< &lt;
  imap ;> &gt;
  nmap  ,= :%s/^===\(.*\)$/<h1>\1<\/h1>/c<CR>
  ab  Ycut  \| <a href="#"<C-I>></a><ESC>F#a
  vmap ,cut  "zdi<a href="#<C-R>z"<C-I>><C-R>z</a><ESC>2F>
augroup END

"Colorful tabs"
hi TabLine      guifg=#333 guibg=#222 gui=none ctermfg=254 ctermbg=238 cterm=none
hi TabLineSel   guifg=#666 guibg=#222 gui=bold ctermfg=231 ctermbg=235 cterm=bold
"hi TabLineFill  guifg=#999 guibg=#222 gui=none ctermfg=254 ctermbg=238 cterm=none
hi TabLineFill guifg=LightGreen guibg=DarkGreen ctermfg=LightGreen ctermbg=DarkGreen
"set bg=light
if  has("gui_running")
  "tab title"
  set guitablabel=%N:\ %t#\%-10.3n\ %M
  "remove toolbar
  "set lines=40
  set guioptions-=T
  set guioptions+=ebLh
  "set guioptions+=c "console dialog instead of popup"
  "--------------preferred--------------------------------------------------------
  "colorscheme darkblue
  "colorscheme wombat "Good
  "colorscheme anotherdark
  "colorscheme blacksea "Good
  "colorscheme camo
  "colorscheme candy
  "colorscheme colorer
  "colorscheme darkZ "Good
  "colorscheme darkspectrum "Good
  "colorscheme zenburn
  "colorscheme rdark
  "colorscheme solarized "Good
  "colorscheme molokai
  "colorscheme two2tango "Good
  "colorscheme evening
  "colorscheme darkblue
  "colorscheme desertEx
  "colorscheme desertedocean
  "colorscheme koehler
  "colorscheme mayansmoke "Good light
  "colorscheme mickeysoft "Good light
  "colorscheme mophiaSmoke "Good light
  "colorscheme gruvbox "Good
  "colorscheme badwolf
  "colorscheme nocturne
  "colorscheme molokai
  "colorscheme emacs
  colorscheme vimhut
  "colorscheme pyte
  "colorscheme greyhouse
  "colorscheme solarized
  "colorscheme peaksea
  "colorscheme grape
  "colorscheme bclear
  "set background=light
  "colorscheme habilight "Good light
  "colorscheme earendel "white Good
  "colorscheme codeblocks_dark "Good
  "colorscheme manuscript "Good
  "colorscheme mint "Good
  "colorscheme mrpink "Good
  "colorscheme mustang "Good
  "colorscheme moria "little dull
  "FIXME
  "TODO
  "colorscheme jellybeans "Good
  "colorscheme railscasts "Good
  "colorscheme twilight "Good
  "colorscheme molokai "Good
  "colorscheme xoria256 "Good
  "colorscheme symfony
  set cursorline
  set cursorcolumn
  """"""""""""""""""""""""""""""
  " => Statusline
  """"""""""""""""""""""""""""""
  let g:Powerline_colorscheme = 'solarized'
  "--------------------------------------------------------------------------------
  "
  "--------------------------------------------------------------------------------
else
    let g:Powerline_colorscheme = 'solarized'
    highlight Normal ctermfg=grey ctermbg=darkblue
    set bg=light
    "set bg=light
    "colorscheme desert
    "colorscheme slate
    "colorscheme aiseered
    "colorscheme manxome
    "colorscheme jellybeans
    "colorscheme candy
    "colorscheme default
    "colorscheme torte
    "colorscheme earendel "Black Good
    "colorscheme default
    "colorscheme murphy "Black
    colorscheme molokai
    "colorscheme default
    "colorscheme badwolf
    "colorscheme metacosm "Black
    "colorscheme motus "Black
    "colorscheme midnight2 "Blue
    "set guifont=-b&h-lucidatypewriter-medium-r-normal-*-*-140-*-*-m-*-iso8859-15
    set mouse=a
    "set t_Co=256
    "FIXING the arrow problem
    imap <ESC>oA <ESC>ki
    imap <ESC>oB <ESC>ji
    imap <ESC>oC <ESC>li
    imap <ESC>oD <ESC>hi
    "Setting light background
endif
"
 " Uncomment the following to have Vim jump to the last position when
 " reopening a file
  if has("autocmd")
    au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif
  endif

nnoremap <F1> :BuffergatorToggle<CR>
let g:buffergator_suppress_keymaps=1
nnoremap <F2> :NERDTreeToggle<CR>
 "If there is an issue in Nerdtree
 "Cannot browse subdirs
let g:NERDTreeDirArrows=0
let NERDTreeShowHidden=1
let NERDTreeIgnore=['\~$', '\.swp$', '\.git', '\.hg', '\.svn', '\.bzr']
let NERDSpaceDelims=1
 "
command! CPWD cd %:p:h
command! LPWD lcd %:p:h
command! TOT lcd `my_depth`
""""""""""""""""""""""""""""""
" => Visual mode related
""""""""""""""""""""""""""""""
" Really useful!
"  In visual mode when you press * or # to search for the current selection
vnoremap  # :call VisualSearch('f')<CR>
vnoremap  * :call VisualSearch('b')<CR>

" When you press gv you vimgrep after the selected text
"vnoremap <silent> gv :call VisualSearch('gv')<CR>
"noremap <leader>g :vimgrep // **/*.<left><left><left><left><left><left><left>

function! CmdLine(str)
  exe "menu Foo.Bar :" . a:str
  emenu Foo.Bar
  unmenu Foo
endfunction

" From an idea by Michael Naumann
function! VisualSearch(direction) range
  let l:saved_reg = @"
  execute "normal! vgvy"

  let l:pattern = escape(@", '\\/.*$^~[]')
  let l:pattern = substitute(l:pattern, "\n$", "", "")

  if a:direction == 'b'
    "execute "normal ?" . l:pattern . "^M"
    execute "normal ?" . l:pattern
  elseif a:direction == 'gv'
    call CmdLine("vimgrep " . '/'. l:pattern . '/' . ' **/*.')
  elseif a:direction == 'f'
    "execute "normal /" . l:pattern . "^M"
    execute "normal /" . l:pattern
  endif

  let @/ = l:pattern
  let @" = l:saved_reg
endfunction

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Command mode related
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Smart mappings on the command line
cno $c <C-U>sp <C-\>eCurrentFile("sp")<cr>
cno $C <C-U>tabe <C-\>eCurrentFile("tabe")<cr>
cno $p <C-U>sp <C-\>eCurrentFileDir("sp")<cr>
"cno $P <C-U>tabe <C-\>eCurrentFileDir("tabe")<cr>
cno $P <C-U>vs <C-\>eCurrentFileDirP4("vs")<cr>
cno $b <C-U>sp \| enew \| setlocal bt=nofile bh=delete \| r !`depth`/bin/p4blame <C-r>=resolve(expand('%'))<CR>:<C-R>=line(".")<CR>
cno $E <C-U>sp \| enew \| setlocal bt=nofile bh=delete \| r !p4 edit <C-r>=resolve(expand('%'))<CR>
cno $R <C-U>sp \| enew \| setlocal bt=nofile bh=delete \| r !p4 revert <C-r>=resolve(expand('%'))<CR>
cno $A <C-U>sp \| enew \| setlocal bt=nofile bh=delete \| r !p4 add <C-r>=resolve(expand('%'))<CR>
cno $a <C-U>sp \| enew \| setlocal bt=nofile bh=delete \| r !p4 annotate <C-r>=resolve(expand('%'))<CR>
cno $L <C-U>sp \| enew \| setlocal bt=nofile bh=delete \| r !p4 filelog <C-r>=resolve(expand('%'))<CR>
cno $l <C-U>sp \| enew \| setlocal bt=nofile bh=delete \| r !/home/nv/bin//p4print <C-r>=resolve(expand('%'))<CR>
cno $D <C-U>!p4 diff <C-r>=resolve(expand('%'))<CR> &
cno $d <C-U>sp \| enew \| setlocal bt=nofile bh=delete \| r !p4 describe <C-r><C-w>
cno $N <C-U>!nedit <C-r>=resolve(expand('%'))<CR>
cno $G <C-U>!gnome-terminal &
cno $X <C-U>!xterm -e xx &
cno $K <C-U>!konsole &
cno $M <C-U>!pwd \| mutt -s <C-r>=resolve(expand('%'))<CR> -a <C-r>=resolve(expand('%'))<CR> $USER@nvidia.com
cno $m <C-U>:set modifiable!
cno $H <C-U>sp \| enew \| setlocal bt=nofile bh=delete \| r !p4 have <C-r>=resolve(expand('%'))<CR>
cno $S <C-U>sp \| enew \| setlocal bt=nofile bh=delete \| r !p4 sync <C-r>=resolve(expand('%'))<CR>
cno $T <C-U>sp <C-\>eMy_Depth("tabe")<cr>/
cno $t <C-U>tabe <C-\>eMy_Depth("NERDTree")<cr>/
cno $V <C-U>vs <C-\>eMy_Depth("vs")<cr>/
cno $v <C-U>vs <C-\>eMy_Depth("sp")<cr>/
cno $F <C-U>set filetype=verilog_systemverilog
cno $x <C-U>.s/\\d\\+/\\=printf("0x%04x", submatch(0))
cno $Z <C-U>!tar cvf %.tar <C-r>=resolve(expand('%'))<CR> && mutt -s <C-r>=resolve(expand('%'))<CR> -a %.tar $USER@nvidia.com < /dev/null && \rm -f %.tar
" map %
"cnoremap %% <C-r>=expand('%')<CR>
cnoremap %% <C-r>=resolve(expand('%'))<CR>

" $q is super useful when browsing on the command line
"cno $q <C-\>eDeleteTillSlash()<cr>

" Bash like keys for the command line
func! Cwd()
  let cwd = getcwd()
  return "e " . cwd
endfunc

func! DeleteTillSlash()
  let g:cmd = getcmdline()
  if MySys() == "linux" || MySys() == "mac"
    let g:cmd_edited = substitute(g:cmd, "\\(.*\[/\]\\).*", "\\1", "")
  else
    let g:cmd_edited = substitute(g:cmd, "\\(.*\[\\\\]\\).*", "\\1", "")
  endif
  if g:cmd == g:cmd_edited
    if MySys() == "linux" || MySys() == "mac"
      let g:cmd_edited = substitute(g:cmd, "\\(.*\[/\]\\).*/", "\\1", "")
    else
      let g:cmd_edited = substitute(g:cmd, "\\(.*\[\\\\\]\\).*\[\\\\\]", "\\1", "")
    endif
  endif
  return g:cmd_edited
endfunc

func! CurrentFile(cmd)
  return a:cmd . " ./" . resolve(expand("%:p:t:r")) . "."
endfunc
func! CurrentFileDir(cmd)
  return a:cmd . " " . resolve(expand("%:p:r")) . ""
endfunc
func! CurrentFileDirP4(cmd)
  return a:cmd . " | enew | setlocal bt=nofile |  r !p4 print -q " . resolve(expand("%:p")) . ""
endfunc
function! My_Depth(cmd)
  let output=system("/home/rmondal/bin/scripts/my_depth")
  return a:cmd . " " . output . ""
endfunction
function! My_DepthNoSpace(cmd)
  let output=system("/home/rmondal/bin/scripts/my_depth")
  return a:cmd . "" . output . ""
endfunction
func! CurrentFileUnite(cmd)
  return "Unite -buffer-name=files -input=" . expand("%:p:t:r") . " file_rec:" . a:cmd
endfunc
""""""""""""""""""""""""""""""
" => Statusline
""""""""""""""""""""""""""""""
" Always hide the statusline
let g:Powerline_symbols = 'compatible'
let g:Powerline_cache_enabled = 0
let g:Powerline_mode_V = 'V-L'
let g:Powerline_mode_cv = 'V-B'
let g:Powerline_mode_n = 'N'
let g:Powerline_mode_i = 'I'
let g:Powerline_mode_R = 'R'
let g:Powerline_mode_v = 'V'
if has('gui_running')
  "call Pl#Theme#RemoveSegment('fileencoding')
  "call Pl#Theme#RemoveSegment('fileformat')
  "call Pl#Theme#InsertSegment('filesize', 'before', 'filetype')
  "call Pl#Theme#InsertSegment('pwd', 'before', 'filesize')
  "airline settings
  "nice looking fonts
  function! AirlineInit()
    let g:airline_exclude_preview = 1
    let spc = g:airline_symbols.space
    let g:airline_inactive_collapse=1
    let g:airline_powerline_fonts=1
    let g:airline_powerline_symbol=1
    "let g:airline_theme='light'
    "let g:airline_theme='wombat'
    let g:airline_theme='dark'
    "let g:airline_theme='zenburn'
    " remove separators
    "let g:airline_left_sep=''
    "let g:airline_right_sep=''
    " remove unused modes
    "let g:airline_enable_fugitive=0
    "let g:airline_enable_syntastic=0
    " put filetype in fifth section
    "let g:airline_section_b = 'File:%t %m'
    let g:airline_section_c = airline#section#create(['%<', 'file', spc, 'readonly'])
    call airline#parts#define_function('cwd', 'getcwd')
    call airline#parts#define_minwidth('cwd', 80) "adjust as necessary, it'll check against windwidth()
    let g:airline_section_b = airline#section#create(['Buf#[%n] ', 'cwd']) "'Buf#[%{bufnr("%")}] Path:%{getcwd()} '
    "let g:airline_section_gutter = ""
    let g:airline_section_x = "" "airline#section#create_right(['tagbar'])
    let g:airline_section_y = "Type:%Y"
    if &encoding == "utf-8"
      let g:airline_section_z = "%3p%% : \ue0a1:%l/%L: Col:%3c"
    else
      let g:airline_section_z = "%3p%% : Line:%l/%L: Col:%3c"
    endif
    let g:airline_section_warning = ""
    let g:airline#extensions#tabline#enabled=0
    let g:airline#extensions#tabline#show_buffers = 1
    let g:airline#extensions#tabline#buffer_nr_show = 1
    let g:airline#extensions#tabline#tab_nr_type = 1 " tab number
    let g:airline#extensions#tagbar#enabled = 1
    let g:airline#extensions#tabline#fnamemod = ':t'
    let g:airline_mode_map = {
          \ '__' : '-',
          \ 'n'  : 'N',
          \ 'i'  : 'I',
          \ 'R'  : 'R',
          \ 'c'  : 'C',
          \ 'v'  : 'V',
          \ 'V'  : 'V',
          \ '' : 'V',
          \ 's'  : 'S',
          \ 'S'  : 'S',
          \ '' : 'S',
          \ }
  endfunction
  autocmd VimEnter * call AirlineInit()
endif

" Format the statusline
" %= is to right align
if !has('gui_running')
  "    "set statusline=\ %{HasPaste()}%F%m%r%h\ %w\ \ CWD:\ %r%{CurDir()}%h\ \ \ Line:\ %l/%L:%c
  "    set statusline=\ %{HasPaste()}%F%m%r%h\ %w\
  "    set statusline+=%=Line:\ %l/%L(%p%%):%c
  "    set statusline+=\
  "    set statusline+=Ftype:
  "    set statusline+=%y
endif

"======[ Magically build interim directories if necessary ]===================
function! AskQuit (msg, options, quit_option)
    if confirm(a:msg, a:options) == a:quit_option
        exit
    endif
endfunction

function! EnsureDirExists ()
    let required_dir = expand("%:h")
    if !isdirectory(required_dir)
        call AskQuit("Parent directory '" . required_dir . "' doesn't exist.",
             \       "&Create it\nor &Quit?", 2)

        try
            call mkdir( required_dir, 'p' )
        catch
            call AskQuit("Can't create '" . required_dir . "'",
            \            "&Quit\nor &Continue anyway?", 1)
        endtry
    endif
endfunction
augroup AutoMkdir
    autocmd!
    autocmd  BufNewFile  *  :call EnsureDirExists()
augroup END

function! CurDir()
  let curdir = substitute(getcwd(), $HOME, "~/", "g")
  return curdir
endfunction

function! HasPaste()
  if &paste
    return 'PASTE MODE  '
  else
    return ''
  endif
endfunction

"set the color of the cursor line
"hi Cursorline
let g:cursorcross_disable = 0
let g:cursorcross_dynamic = 'clw'
"hi Cursorline cterm=bold ctermbg=None ctermfg=None guibg=#555555
"autocmd InsertEnter * hi Cursorline cterm=Bold ctermbg=None ctermfg=None guibg=black
"autocmd InsertLeave * hi Cursorline cterm=Bold ctermbg=None ctermfg=None guibg=#555555
"highlight cCursor guifg=white guibg=steelblue ctermfg=Black ctermbg=blue
"
"line number highlight
"hi LineNr guifg=black

"*** Search Highlighting ***
"highlight Search ctermbg=DarkCyan
"guibg=blue
"guifg=red
highlight clear Folded
highlight Folded term=bold gui=bold
set foldopen-=search
"search and replace
" Make a simple "search" text object. gn replaces this so no need
"vnoremap <silent> s //e<C-r>=&selection=='exclusive'?'+1':''<CR><CR>
"    \:<C-u>call histdel('search',-1)<Bar>let @/=histget('search',-1)<CR>gv
"onoremap s :normal vs<CR>
"call AutoHighlightToggle()
"function AutoHighlightToggle()
"        augroup auto_highlight
"        au!
"        au CursorHold * let @/ = '\V\<'.escape(expand('<cword>'), '\').'\>'
"        augroup end
"        setl updatetime=200
"endfunction
"

"so that i can move out of the terminal
let g:ConqueTerm_ReadUnfocused = 1

"Filter out the greppings
command! -nargs=? Filter let @i='' | execute 'g/<args>/y I' | redraw | new | setlocal bt=nofile | put! I
" bind K to grep word under cursor
nnoremap K :execute "vimgrep /" . expand("<cword>") . "/j " . expand("%")
function! GrepQuickFix(pat)
  let all = getqflist()
  for d in all
    if bufname(d['bufnr']) !~ a:pat && d['text'] !~ a:pat
        call remove(all, index(all,d))
    endif
  endfor
  call setqflist(all)
endfunction
command! -nargs=* GrepQF call GrepQuickFix(<q-args>)
nnoremap <C-n> :cnext<CR>
nnoremap <C-p> :cprev<CR>

command! -nargs=0 Blame :call P4blame()
function! P4blame()
  exec "!`my_depth`/bin/p4blame %:" . line(".")
endfunction
"MRU CONFIG
let MRU_Exclude_Files = '^/tmp/.*\|^/var/tmp/.*'  " For Unix
let MRU_Max_Entries = 100
"FuzzyFinder
"let g:fuf_keyOpen='<CR>'
"let g:fuf_keyOpenSplit='<C-s>'
"let g:fuf_keyOpenVsplit='<C-v>'
"let g:fuf_keyOpenTabpage='<C-t'

noremap <F4> :FufFile<CR>
noremap <F3> :FufBuffer<CR>
"noremap <F5> :BufExplorerVerticalSplit<CR>
noremap <F5> :<C-u>GundoToggle<CR>
noremap <F6> :UndotreeToggle<CR>
"let g:tagbar_usearrows = 1
noremap <F7> :TlistToggle<CR>
"noremap <F7> :YRShow<CR>
nnoremap * *''zz
nnoremap g* g*''zz
nnoremap # #''zz
nnoremap g# g#''zz
"nnoremap <silent> n n:call HLNext(0.2)<cr>
"nnoremap <silent> N N:call HLNext(0.2)<cr>
" hex dec conversion
" Return hex string equivalent to given decimal string or number.
function! Dec2hex(arg)
  return printf('%x', a:arg + 0)
endfunction
" Return number equivalent to given hex string ('0x' is optional).
function! Hex2dec(arg)
  return (a:arg =~? '^0x') ? a:arg + 0 : ('0x'.a:arg) + 0
endfunction

" blink search results
" EITHER blink the line containing the match...
function! HLNext (blinktime)
  set invcursorline
  redraw
  exec 'sleep ' . float2nr(a:blinktime * 1000) . 'm'
  set invcursorline
  redraw
endfunction
"
" OR ELSE ring the match in red...
"function! HLNext (blinktime)
"  highlight RedOnRed ctermfg=red ctermbg=red
"  let [bufnum, lnum, col, off] = getpos('.')
"  let matchlen = strlen(matchstr(strpart(getline('.'),col-1),@/))
"  echo matchlen
"  let ring_pat = (lnum > 1 ? '\%'.(lnum-1).'l\%>'.max([col-4,1]) .'v\%<'.(col+matchlen+3).'v.\|' : '')
"        \ . '\%'.lnum.'l\%>'.max([col-4,1]) .'v\%<'.col.'v.'
"        \ . '\|'
"        \ . '\%'.lnum.'l\%>'.max([col+matchlen-1,1]) .'v\%<'.(col+matchlen+3).'v.'
"        \ . '\|'
"        \ . '\%'.(lnum+1).'l\%>'.max([col-4,1]) .'v\%<'.(col+matchlen+3).'v.'
"  let ring = matchadd('RedOnRed', ring_pat, 101)
"  redraw
"  exec 'sleep ' . float2nr(a:blinktime * 1000) . 'm'
"  call matchdelete(ring)
"  redraw
"endfunction
"
" OR ELSE briefly hide everything except the match...
"function! HLNext (blinktime)
"  highlight BlackOnBlack ctermfg=black ctermbg=black
"  let [bufnum, lnum, col, off] = getpos('.')
"  let matchlen = strlen(matchstr(strpart(getline('.'),col-1),@/))
"  let hide_pat = '\%<'.lnum.'l.'
"        \ . '\|'
"        \ . '\%'.lnum.'l\%<'.col.'v.'
"        \ . '\|'
"        \ . '\%'.lnum.'l\%>'.(col+matchlen-1).'v.'
"        \ . '\|'
"        \ . '\%>'.lnum.'l.'
"  let ring = matchadd('BlackOnBlack', hide_pat, 101)
"  redraw
"  exec 'sleep ' . float2nr(a:blinktime * 1000) . 'm'
"  call matchdelete(ring)
"  redraw
"endfunction
highlight WHITE_ON_RED    ctermfg=white  ctermbg=red
"OR ELSE just highlight the match in red...
"function! HLNext (blinktime)
"  let [bufnum, lnum, col, off] = getpos('.')
"  let matchlen = strlen(matchstr(strpart(getline('.'),col-1),@/))
"  let target_pat = '\c\%#'.@/
"  let ring = matchadd('WHITE_ON_RED', target_pat, 101)
"  redraw
"  exec 'sleep ' . float2nr(a:blinktime * 1000) . 'm'
"  call matchdelete(ring)
"  redraw
"endfunction

"map so that ctrl-g shows the full path"
nnoremap <C-g>  11<C-g>
"Yank from the cursor to the end of the line, to be consistentwith C and D.
nnoremap Y y$
inoremap <c-s> <esc>ddi
"cmap Tabe tabe
" visual shifting (does not exit Visual mode)
"vnoremap < <gv
"vnoremap > >gv
"visual drag
"vnoremap  <expr>  <S-LEFT>   DVB_Drag('left')
"vnoremap  <expr>  <S-RIGHT>  DVB_Drag('right')
"vnoremap  <expr>  <S-DOWN>   DVB_Drag('down')
"vnoremap  <expr>  <S-UP>     DVB_Drag('up')
"vnoremap  <expr>  D          DVB_Duplicate()
vnoremap <S-Right>  xpgvlolo
vnoremap <S-left>   xhPgvhoho
vnoremap <S-Down>   xjPgvjojo
vnoremap <S-Up>     xkPgvkoko

"math "
vmap <expr>  ++  VMATH_YankAndAnalyse()
"" Temporarily add a column indicator when inserting or appending in visual mode...
"" (Should use <C-O> instead, but it doesn't seem to work)
let g:cursorcolumn_visible = 1
"vnoremap <silent>  I  I<C-R>=TemporaryColumnMarkerOn()<CR>
"vnoremap <silent>  A  A<C-R>=TemporaryColumnMarkerOn()<CR>
"
"function! TemporaryColumnMarkerOn ()
"  let g:prev_cursorcolumn_state = g:cursorcolumn_visible ? 'on' : 'off'
"  call Toggle_CursorColumn('on')
"  inoremap <silent>  <ESC>  <ESC>:call TemporaryColumnMarkerOff(g:prev_cursorcolumn_state)<CR>
"  return ""
"endfunction
"
"function! TemporaryColumnMarkerOff (newstate)
"  call Toggle_CursorColumn(a:newstate)
"  iunmap <ESC>
"endfunction
"
"" Implement cursor toggle...
"let g:cursorcolumn_visible = 0
"function! Toggle_CursorColumn (requested_state)
"  if a:requested_state == 'off' || g:cursorcolumn_visible && a:requested_state == 'flip'
"    let g:cursorcolumn_visible = 0
"    highlight clear CursorColumn
"    highlight CursorColumn term=none cterm=none
"  else
"    let g:cursorcolumn_visible = 1
"    highlight CursorColumn term=bold ctermfg=black ctermbg=cyan cterm=bold
"  endif
"endfunction

"CoVim settings"
let CoVim_default_name = "rmondal"
let CoVim_default_port = "3456"

let g:Perl_AuthorName      = 'Rajdeep'
let g:Perl_AuthorRef       = ''
let g:Perl_Email           = '$USER@nvidia'
let g:Perl_Company         = 'nVidia'
"disable boilter plate code insertion"
let g:Perl_TemplateOverwrittenMsg= 'no'

" SnipMate {
" Setting the author var
" If forking, please overwrite in your .vimrc.local file
let g:snips_author = 'Rajdeep <[[$USER@nvidia.com]](mailto:$USER@nvidia.com)>'

"this is only for me
"nnoremap <left> <nop>
"nnoremap <right> <nop>
"nnoremap <up> <nop>
"nnoremap <down> <nop>
if has('win32')
  "Avoid mswin.vim making Ctrl-v as paste
  noremap <C-V> <C-V>
  "make arrow keys extend visual
  set keymodel-=stopsel
  behave win32
  "colorscheme lettuce
  set guifont=Lucida\ Console:h11
  "set guifont=*
  ":FontList
  ":Font Dingbats
  ":FontSize 14
  ":FontStyle bold italic
else
  "set guifont=Courier\ New\ 12
  "set guifont=Droid\ Sans\ Mono\ 12
  "set guifont=Bitstream\ Charter\ 12
  "set guifont=Century\ Schoolbook\ L\ 12
  "set guifont=DejaVu\ Sans\ Mono\ 12
  "
  set guifont=Monaco\ 11 "favourite
  "set guifont=Ubuntu\ Mono\ 14 "beautiful
  "set guifont=Menlo\ 12 "favourite
  "set guifont=Fira\ Mono\ 12 "beautiful
  "set guifont=Consolas\ for\ Powerline\ 13
  "set guifont=BPmono\ 14
  "set guifont=PT\ Mono\ 13
  "
  "set guifont=DejaVu\ LGC\ Sans\ Mono\ 12
  "set guifont=Andale\ Mono\ 14
  "set guifont=Monofur\ 14
  "set guifont=Consolas\ 13
  "set guifont=Inconsolata\ 14
  "set guifont=Monospace\ 14
  "set guifont=*
  ":FontList
  ":Font Dingbats
  ":FontSize 14
  ":FontStyle bold italic
endif

" Use local vimrc if available {
"if filereadable(expand("\~/.vimrc.local"))
"    source \~/.vimrc.local
"endif
" }
"custom files to source
"if filereadable(expand("\~/.vim/cus_fold/folding.vim"))
"    source \~/.vim/cus_fold/folding.vim
"endif
"fold --> check if file has folding then show foldcolum"
"function HasFoldedLine()
"    let lnum=1
"    while lnum <= line("$")
"        if (foldclosed(lnum) > -1)
"            return 1
"        endif
"        let lnum+=1
"    endwhile
"    return 0
" endfu
":au CursorHold * if HasFoldedLine() == 1 | set fdc=1 | else |set fdc=0 | endif
" Multicursor "
let g:multi_cursor_exit_from_visual_mode=0
let g:multi_cursor_exit_from_insert_mode=0
"Unite configurations"
let g:unite_source_history_yank_enable = 1
let g:unite_source_history_yank_limit=1000
let g:yankring_max_history = 1000
let g:yankring_manage_numbered_reg = 1
call unite#filters#matcher_default#use(['matcher_fuzzy'])
let g:unite_enable_start_insert=1
let g:unite_source_rec_max_cache_files=100000
call unite#custom#source('file_rec', 'ignore_pattern', '\.abc$')
call unite#custom#source('file_rec', 'max_candidates', '0')
call unite#custom#source('file', 'max_candidates', '0')
"let g:unite_source_grep_command='ack'
"let g:unite_source_grep_default_opts='--no-heading --no-color -a -C4'
"let g:unite_source_grep_recursive_opt=''
"let g:unite_source_find_command =
"    \ 'find `depth` -type f -o \( -name .git -o -name tmp -o -name .hg -name .svn \) -prune -type f | head -100 | grep -v -E "\.(jpe?g|png|gif|[ot]tf|ico)$"'
"let g:unite_source_rec_async_command=
"  \ 'find `depth` -type f -o \( -name .git -o -name tmp -o -name .hg -name .svn \) -prune -type f | head -100 | grep -v -E "\.(jpe?g|png|gif|[ot]tf|ico)$"'
"nnoremap <leader>t :<C-u>Unite -buffer-name=files   file_rec:<C-\>eMy_DepthNoSpace("Unite -buffer-name=files   file_rec:")<cr>/
nnoremap <leader>d :<C-u>Unite -buffer-name=files   file_rec:<C-\>eMy_DepthNoSpace("Unite -buffer-name=dir   directory:")<cr>/
"nnoremap <leader>f :<C-u>Unite -buffer-name=files   file<cr>
nnoremap <leader>fr :<C-u>Unite -buffer-name=files   file_rec:../../
nnoremap <leader>ft :<C-u><C-\>eCurrentFileUnite("../..")<cr>
nnoremap <leader>o :<C-u>Unite -buffer-name=outline outline<cr>
nnoremap <leader>c :<C-u>Unite -buffer-name=output output<cr>
nnoremap <leader>y :<C-u>Unite -buffer-name=yank    history/yank<cr>
nnoremap <leader>h :<C-u>Unite -buffer-name=yank    history/yank<cr>
nnoremap <leader>r :<C-u>Unite -buffer-name=yank    register<cr>
nnoremap <leader>b :<C-u>Unite -buffer-name=buffer  buffer<cr>
nnoremap <leader>q :<C-u>Unite -buffer-name=quickfix qflist<cr>
nnoremap <leader>g :<C-u>Unite -buffer-name=grep  vimgrep:%<cr>
nnoremap <leader>gb :<C-u>Unite -buffer-name=grep  vimgrep:##<cr>
nnoremap <leader>l :<C-u>Unite -buffer-name=search  line<cr>
autocmd FileType unite call s:unite_my_settings()
function! s:unite_my_settings()
  "set paste
  " Play nice with supertab
  let b:SuperTabDisabled=1
  " Overwrite settings.
  inoremap <silent><buffer><expr> <C-s>     unite#do_action('split')
  inoremap <silent><buffer><expr> <C-v>     unite#do_action('vsplit')
  "imap <buffer> <esc> <plug>(unite_exit)
  nnoremap <buffer> <esc> <plug>(unite_exit)
  nnoremap <buffer> <C-j> <plug>(unite_toggle_auto_preview)
  inoremap <buffer> <TAB> <plug>(unite_select_next_line)
  inoremap <buffer> <S-TAB> <plug>(unite_select_previous_line)
  inoremap <buffer> <BS> <BS>
endfunction

"NarrowRegion Writeback"
let g:nrrw_rgn_protect = 'n'

"UltiSnips"
let g:UltiSnipsSnippetDirectories=["UltiSnips", "mysnippets"]
"let g:ycm_cache_omnifunc = 1
let g:UltiSnipsExpandTrigger="<C-Space>"
let g:UltiSnipsJumpForwardTrigger="<C-Space>"
let g:UltiSnipsListSnippets="<S-Space>"
let g:UltiSnipsJumpBackwardTrigger="<C-S-Space>"
"
" neosnippet"
"imap <C-k>     <Plug>(neosnippet_expand_or_jump)
"smap <C-k>     <Plug>(neosnippet_expand_or_jump)
"xmap <C-k>     <Plug>(neosnippet_expand_target)
"" SuperTab like snippets behavior.
""imap <expr><TAB> neosnippet#expandable_or_jumpable() ?
""\ "\<Plug>(neosnippet_expand_or_jump)"
""\: pumvisible() ? "\<C-n>" : "\<TAB>"
""smap <expr><TAB> neosnippet#expandable_or_jumpable() ?
""\ "\<Plug>(neosnippet_expand_or_jump)"
""\: "\<TAB>"
"let g:neosnippet#snippets_directory='~/.vim/bundle/snippets/snippets, ~/.vim/mysnippets/'
"let g:neosnippet#enable_preview=1
"let g:neosnippet#enable_snipmate_compatibility = 1

"", ~/.vim/bundle/snippets/UltiSnips, ~/.vim/mysnippets/'

"let g:UltiSnipsJumpForwardTrigger="<c-j>"
"let g:UltiSnipsJumpBackwardTrigger="<c-k>"
"
let g:matchparen_insert_timeout=5
" Underline the current line with various symbols (such that the number of
" underline matches line length and indendation)
nnoremap <Leader>= yypv$r=
nnoremap <Leader>- yypv$r-
nnoremap <Leader># yypv$r#
nnoremap <Leader>" yypv$r"
" A fancy unicode underline
nnoremap <Leader>U yypv$r-
" get back space behaviour
" Pydiction path
let g:pydiction_location = '~/.vim/bundle/Pydiction/complete-dict'

" load filetype detection last"
set iskeyword+=_
set iskeyword-='
set iskeyword-=:
syntax on
filetype on
filetype plugin on
filetype indent on
"set omnifunc=syntaxcomplete#Complete
